//#include <math.h>

#include "SimulationFunctions_MRG32k3a.h"

double rand_u01(double dseed[])
{
	//	This code is an exact copy of the C code in L'Ecuyer (Operations Research 1999)
	const double norm = 2.328306549295728e-10;
	const double m1 = 4294967087.0;
	const double m2 = 4294944443.0;
	const double a12 = 1403580.0;
	const double a13n = 810728.0;
	const double a21 = 527612.0;
	const double a23n = 1370589.0;
	int k;
	double p1, p2;

	p1 = a12*dseed[1] - a13n*dseed[2];
	k = p1 / m1;
	p1 -= k*m1;
	if (p1 < 0.0) p1 += m1;
	dseed[2] = dseed[1]; dseed[1] = dseed[0]; dseed[0] = p1;

	p2 = a21*dseed[3] - a23n*dseed[5];
	k = p2 / m2;
	p2 -= k*m2;
	if (p2 < 0.0) p2 += m2;
	dseed[5] = dseed[4]; dseed[4] = dseed[3]; dseed[3] = p2;

	if (p1 <= p2) return ((p1 - p2 + m1)*norm);
	else return ((p1 - p2)*norm);

}

void roll_seedCPU(double dseed[])
{
	const double m1 = 4294967087.0;
	const double m2 = 4294944443.0;
	const double a12 = 1403580.0;
	const double a13n = 810728.0;
	const double a21 = 527612.0;
	const double a23n = 1370589.0;
	int k;
	double p1, p2;

	p1 = a12*dseed[1] - a13n*dseed[2];
	k = p1 / m1;
	p1 -= k*m1;
	if (p1 < 0.0) p1 += m1;
	dseed[2] = dseed[1]; dseed[1] = dseed[0]; dseed[0] = p1;

	p2 = a21*dseed[3] - a23n*dseed[5];
	k = p2 / m2;
	p2 -= k*m2;
	if (p2 < 0.0) p2 += m2;
	dseed[5] = dseed[4]; dseed[4] = dseed[3]; dseed[3] = p2;

	return;

}

//	This method is slightly faster and accurate (always spot on, matches brute force rolling of seeds)
//	This method is very fast because it uses divdie and conquer
void SkipAhead_MRG32k3a(int n, unsigned int **An1, unsigned int **An2)
{
	const unsigned int im1 = 4294967087;
	const unsigned int im2 = 4294944443;
	const unsigned int ia12 = 1403580;
	const unsigned int ia13n = 810728;
	const unsigned int ia21 = 527612;
	const unsigned int ia23n = 1370589;
	int i, j, k, ii;
	long long kmod, lp1, lp2;
	long long A1[3][3], A2[3][3], B1[3][3], B2[3][3], C1[3][3], C2[3][3];
	unsigned long long BB1[3][3], BB2[3][3], CC1[3][3], CC2[3][3];

	A1[0][0] = 0; A1[0][1] = ia12;
	A1[0][2] = 0;
	A1[0][2] -= ia13n;
	//	A1[0][2] = -ia13n;
	A1[1][0] = 1; A1[1][1] = 0; A1[1][2] = 0;
	A1[2][0] = 0; A1[2][1] = 1; A1[2][2] = 0;

	A2[0][0] = ia21; A2[0][1] = 0;
	A2[0][2] = 0;
	A2[0][2] -= ia23n;
	//	A2[0][2] = -ia23n;
	A2[1][0] = 1; A2[1][1] = 0; A2[1][2] = 0;
	A2[2][0] = 0; A2[2][1] = 1; A2[2][2] = 0;

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			B1[i][j] = A1[i][j];
			B2[i][j] = A2[i][j];
		}
	}

	//	printf(" initial A1: \n");
	//	for (i = 0; i < 3; i++) {
	//		for (j = 0; j < 3; j++) printf(" %12lli ", A1[i][j]);
	//		printf("  \n");
	//	}
	//	printf(" initial A2: \n");
	//	for (i = 0; i < 3; i++) {
	//		for (j = 0; j < 3; j++) printf(" %12lli ", A2[i][j]);
	//		printf("  \n");
	//	}

	for (ii = 2; ii <= 4; ii++) {
		//	pre-multiply by Ai, calculating with 64 bit signed integers
		C1[0][0] = A1[0][0] * B1[0][0] + A1[0][1] * B1[1][0] + A1[0][2] * B1[2][0];
		C1[0][1] = A1[0][0] * B1[0][1] + A1[0][1] * B1[1][1] + A1[0][2] * B1[2][1];
		C1[0][2] = A1[0][0] * B1[0][2] + A1[0][1] * B1[1][2] + A1[0][2] * B1[2][2];
		C1[1][0] = A1[1][0] * B1[0][0] + A1[1][1] * B1[1][0] + A1[1][2] * B1[2][0];
		C1[1][1] = A1[1][0] * B1[0][1] + A1[1][1] * B1[1][1] + A1[1][2] * B1[2][1];
		C1[1][2] = A1[1][0] * B1[0][2] + A1[1][1] * B1[1][2] + A1[1][2] * B1[2][2];
		C1[2][0] = A1[2][0] * B1[0][0] + A1[2][1] * B1[1][0] + A1[2][2] * B1[2][0];
		C1[2][1] = A1[2][0] * B1[0][1] + A1[2][1] * B1[1][1] + A1[2][2] * B1[2][1];
		C1[2][2] = A1[2][0] * B1[0][2] + A1[2][1] * B1[1][2] + A1[2][2] * B1[2][2];

		C2[0][0] = A2[0][0] * B2[0][0] + A2[0][1] * B2[1][0] + A2[0][2] * B2[2][0];
		C2[0][1] = A2[0][0] * B2[0][1] + A2[0][1] * B2[1][1] + A2[0][2] * B2[2][1];
		C2[0][2] = A2[0][0] * B2[0][2] + A2[0][1] * B2[1][2] + A2[0][2] * B2[2][2];
		C2[1][0] = A2[1][0] * B2[0][0] + A2[1][1] * B2[1][0] + A2[1][2] * B2[2][0];
		C2[1][1] = A2[1][0] * B2[0][1] + A2[1][1] * B2[1][1] + A2[1][2] * B2[2][1];
		C2[1][2] = A2[1][0] * B2[0][2] + A2[1][1] * B2[1][2] + A2[1][2] * B2[2][2];
		C2[2][0] = A2[2][0] * B2[0][0] + A2[2][1] * B2[1][0] + A2[2][2] * B2[2][0];
		C2[2][1] = A2[2][0] * B2[0][1] + A2[2][1] * B2[1][1] + A2[2][2] * B2[2][1];
		C2[2][2] = A2[2][0] * B2[0][2] + A2[2][1] * B2[1][2] + A2[2][2] * B2[2][2];

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				lp1 = C1[i][j];
				lp1 = lp1 % im1;
				if (lp1 < 0) lp1 += im1;
				B1[i][j] = lp1;
				lp2 = C2[i][j];
				lp2 = lp2 % im2;
				if (lp2 < 0) lp2 += im2;
				B2[i][j] = lp2;
			}
		}

	}

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			BB1[i][j] = B1[i][j];
			BB2[i][j] = B2[i][j];
		}
	}

	ii = 8;
	while (ii <= n) {
		//	here we are squaring the matrix at each round
		CC1[0][0] = ((BB1[0][0] * BB1[0][0]) % im1 + (BB1[0][1] * BB1[1][0]) % im1 + (BB1[0][2] * BB1[2][0]) % im1) % im1;
		CC1[0][1] = ((BB1[0][0] * BB1[0][1]) % im1 + (BB1[0][1] * BB1[1][1]) % im1 + (BB1[0][2] * BB1[2][1]) % im1) % im1;
		CC1[0][2] = ((BB1[0][0] * BB1[0][2]) % im1 + (BB1[0][1] * BB1[1][2]) % im1 + (BB1[0][2] * BB1[2][2]) % im1) % im1;
		CC1[1][0] = ((BB1[1][0] * BB1[0][0]) % im1 + (BB1[1][1] * BB1[1][0]) % im1 + (BB1[1][2] * BB1[2][0]) % im1) % im1;
		CC1[1][1] = ((BB1[1][0] * BB1[0][1]) % im1 + (BB1[1][1] * BB1[1][1]) % im1 + (BB1[1][2] * BB1[2][1]) % im1) % im1;
		CC1[1][2] = ((BB1[1][0] * BB1[0][2]) % im1 + (BB1[1][1] * BB1[1][2]) % im1 + (BB1[1][2] * BB1[2][2]) % im1) % im1;
		CC1[2][0] = ((BB1[2][0] * BB1[0][0]) % im1 + (BB1[2][1] * BB1[1][0]) % im1 + (BB1[2][2] * BB1[2][0]) % im1) % im1;
		CC1[2][1] = ((BB1[2][0] * BB1[0][1]) % im1 + (BB1[2][1] * BB1[1][1]) % im1 + (BB1[2][2] * BB1[2][1]) % im1) % im1;
		CC1[2][2] = ((BB1[2][0] * BB1[0][2]) % im1 + (BB1[2][1] * BB1[1][2]) % im1 + (BB1[2][2] * BB1[2][2]) % im1) % im1;

		CC2[0][0] = ((BB2[0][0] * BB2[0][0]) % im2 + (BB2[0][1] * BB2[1][0]) % im2 + (BB2[0][2] * BB2[2][0]) % im2) % im2;
		CC2[0][1] = ((BB2[0][0] * BB2[0][1]) % im2 + (BB2[0][1] * BB2[1][1]) % im2 + (BB2[0][2] * BB2[2][1]) % im2) % im2;
		CC2[0][2] = ((BB2[0][0] * BB2[0][2]) % im2 + (BB2[0][1] * BB2[1][2]) % im2 + (BB2[0][2] * BB2[2][2]) % im2) % im2;
		CC2[1][0] = ((BB2[1][0] * BB2[0][0]) % im2 + (BB2[1][1] * BB2[1][0]) % im2 + (BB2[1][2] * BB2[2][0]) % im2) % im2;
		CC2[1][1] = ((BB2[1][0] * BB2[0][1]) % im2 + (BB2[1][1] * BB2[1][1]) % im2 + (BB2[1][2] * BB2[2][1]) % im2) % im2;
		CC2[1][2] = ((BB2[1][0] * BB2[0][2]) % im2 + (BB2[1][1] * BB2[1][2]) % im2 + (BB2[1][2] * BB2[2][2]) % im2) % im2;
		CC2[2][0] = ((BB2[2][0] * BB2[0][0]) % im2 + (BB2[2][1] * BB2[1][0]) % im2 + (BB2[2][2] * BB2[2][0]) % im2) % im2;
		CC2[2][1] = ((BB2[2][0] * BB2[0][1]) % im2 + (BB2[2][1] * BB2[1][1]) % im2 + (BB2[2][2] * BB2[2][1]) % im2) % im2;
		CC2[2][2] = ((BB2[2][0] * BB2[0][2]) % im2 + (BB2[2][1] * BB2[1][2]) % im2 + (BB2[2][2] * BB2[2][2]) % im2) % im2;

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				BB1[i][j] = CC1[i][j];
				BB2[i][j] = CC2[i][j];
			}

		}

		ii = 2 * ii;
	}

	k = ii / 2;
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			B1[i][j] = BB1[i][j];
			B2[i][j] = BB2[i][j];
		}
	}

	for (ii = (k + 1); ii <= n; ii++) {
		//	pre-multiply by Ai, calculating with 64 bit signed integers
		C1[0][0] = A1[0][0] * B1[0][0] + A1[0][1] * B1[1][0] + A1[0][2] * B1[2][0];
		C1[0][1] = A1[0][0] * B1[0][1] + A1[0][1] * B1[1][1] + A1[0][2] * B1[2][1];
		C1[0][2] = A1[0][0] * B1[0][2] + A1[0][1] * B1[1][2] + A1[0][2] * B1[2][2];
		C1[1][0] = A1[1][0] * B1[0][0] + A1[1][1] * B1[1][0] + A1[1][2] * B1[2][0];
		C1[1][1] = A1[1][0] * B1[0][1] + A1[1][1] * B1[1][1] + A1[1][2] * B1[2][1];
		C1[1][2] = A1[1][0] * B1[0][2] + A1[1][1] * B1[1][2] + A1[1][2] * B1[2][2];
		C1[2][0] = A1[2][0] * B1[0][0] + A1[2][1] * B1[1][0] + A1[2][2] * B1[2][0];
		C1[2][1] = A1[2][0] * B1[0][1] + A1[2][1] * B1[1][1] + A1[2][2] * B1[2][1];
		C1[2][2] = A1[2][0] * B1[0][2] + A1[2][1] * B1[1][2] + A1[2][2] * B1[2][2];

		C2[0][0] = A2[0][0] * B2[0][0] + A2[0][1] * B2[1][0] + A2[0][2] * B2[2][0];
		C2[0][1] = A2[0][0] * B2[0][1] + A2[0][1] * B2[1][1] + A2[0][2] * B2[2][1];
		C2[0][2] = A2[0][0] * B2[0][2] + A2[0][1] * B2[1][2] + A2[0][2] * B2[2][2];
		C2[1][0] = A2[1][0] * B2[0][0] + A2[1][1] * B2[1][0] + A2[1][2] * B2[2][0];
		C2[1][1] = A2[1][0] * B2[0][1] + A2[1][1] * B2[1][1] + A2[1][2] * B2[2][1];
		C2[1][2] = A2[1][0] * B2[0][2] + A2[1][1] * B2[1][2] + A2[1][2] * B2[2][2];
		C2[2][0] = A2[2][0] * B2[0][0] + A2[2][1] * B2[1][0] + A2[2][2] * B2[2][0];
		C2[2][1] = A2[2][0] * B2[0][1] + A2[2][1] * B2[1][1] + A2[2][2] * B2[2][1];
		C2[2][2] = A2[2][0] * B2[0][2] + A2[2][1] * B2[1][2] + A2[2][2] * B2[2][2];

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				lp1 = C1[i][j];
				lp1 = lp1 % im1;
				if (lp1 < 0) lp1 += im1;
				B1[i][j] = lp1;
				lp2 = C2[i][j];
				lp2 = lp2 % im2;
				if (lp2 < 0) lp2 += im2;
				B2[i][j] = lp2;
			}
		}
	}

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			An1[i][j] = B1[i][j];
			An2[i][j] = B2[i][j];
		}
	}

	return;

}

void SkipAhead2_MRG32k3a(int n, unsigned int **An1, unsigned int **An2, unsigned int **Bn1, unsigned int **Bn2)
{
	const unsigned int im1 = 4294967087;
	const unsigned int im2 = 4294944443;
	int i, j, k, ii;
	long long kmod, lp1, lp2;
	unsigned long long A1[3][3], A2[3][3], BB1[3][3], BB2[3][3], CC1[3][3], CC2[3][3];

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			A1[i][j] = An1[i][j];
			A2[i][j] = An2[i][j];
			BB1[i][j] = An1[i][j];
			BB2[i][j] = An2[i][j];
		}
	}

	ii = 2;
	while (ii <= n) {
		//	here we are squaring the matrix at each round
		CC1[0][0] = ((BB1[0][0] * BB1[0][0]) % im1 + (BB1[0][1] * BB1[1][0]) % im1 + (BB1[0][2] * BB1[2][0]) % im1) % im1;
		CC1[0][1] = ((BB1[0][0] * BB1[0][1]) % im1 + (BB1[0][1] * BB1[1][1]) % im1 + (BB1[0][2] * BB1[2][1]) % im1) % im1;
		CC1[0][2] = ((BB1[0][0] * BB1[0][2]) % im1 + (BB1[0][1] * BB1[1][2]) % im1 + (BB1[0][2] * BB1[2][2]) % im1) % im1;
		CC1[1][0] = ((BB1[1][0] * BB1[0][0]) % im1 + (BB1[1][1] * BB1[1][0]) % im1 + (BB1[1][2] * BB1[2][0]) % im1) % im1;
		CC1[1][1] = ((BB1[1][0] * BB1[0][1]) % im1 + (BB1[1][1] * BB1[1][1]) % im1 + (BB1[1][2] * BB1[2][1]) % im1) % im1;
		CC1[1][2] = ((BB1[1][0] * BB1[0][2]) % im1 + (BB1[1][1] * BB1[1][2]) % im1 + (BB1[1][2] * BB1[2][2]) % im1) % im1;
		CC1[2][0] = ((BB1[2][0] * BB1[0][0]) % im1 + (BB1[2][1] * BB1[1][0]) % im1 + (BB1[2][2] * BB1[2][0]) % im1) % im1;
		CC1[2][1] = ((BB1[2][0] * BB1[0][1]) % im1 + (BB1[2][1] * BB1[1][1]) % im1 + (BB1[2][2] * BB1[2][1]) % im1) % im1;
		CC1[2][2] = ((BB1[2][0] * BB1[0][2]) % im1 + (BB1[2][1] * BB1[1][2]) % im1 + (BB1[2][2] * BB1[2][2]) % im1) % im1;

		CC2[0][0] = ((BB2[0][0] * BB2[0][0]) % im2 + (BB2[0][1] * BB2[1][0]) % im2 + (BB2[0][2] * BB2[2][0]) % im2) % im2;
		CC2[0][1] = ((BB2[0][0] * BB2[0][1]) % im2 + (BB2[0][1] * BB2[1][1]) % im2 + (BB2[0][2] * BB2[2][1]) % im2) % im2;
		CC2[0][2] = ((BB2[0][0] * BB2[0][2]) % im2 + (BB2[0][1] * BB2[1][2]) % im2 + (BB2[0][2] * BB2[2][2]) % im2) % im2;
		CC2[1][0] = ((BB2[1][0] * BB2[0][0]) % im2 + (BB2[1][1] * BB2[1][0]) % im2 + (BB2[1][2] * BB2[2][0]) % im2) % im2;
		CC2[1][1] = ((BB2[1][0] * BB2[0][1]) % im2 + (BB2[1][1] * BB2[1][1]) % im2 + (BB2[1][2] * BB2[2][1]) % im2) % im2;
		CC2[1][2] = ((BB2[1][0] * BB2[0][2]) % im2 + (BB2[1][1] * BB2[1][2]) % im2 + (BB2[1][2] * BB2[2][2]) % im2) % im2;
		CC2[2][0] = ((BB2[2][0] * BB2[0][0]) % im2 + (BB2[2][1] * BB2[1][0]) % im2 + (BB2[2][2] * BB2[2][0]) % im2) % im2;
		CC2[2][1] = ((BB2[2][0] * BB2[0][1]) % im2 + (BB2[2][1] * BB2[1][1]) % im2 + (BB2[2][2] * BB2[2][1]) % im2) % im2;
		CC2[2][2] = ((BB2[2][0] * BB2[0][2]) % im2 + (BB2[2][1] * BB2[1][2]) % im2 + (BB2[2][2] * BB2[2][2]) % im2) % im2;

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				BB1[i][j] = CC1[i][j];
				BB2[i][j] = CC2[i][j];
			}
		}

		ii = 2 * ii;
	}

	k = ii / 2;

	for (ii = (k + 1); ii <= n; ii++) {
		//	pre-multiply by Ai, calculating with 64 bit signed integers

		CC1[0][0] = ((A1[0][0] * BB1[0][0]) % im1 + (A1[0][1] * BB1[1][0]) % im1 + (A1[0][2] * BB1[2][0]) % im1) % im1;
		CC1[0][1] = ((A1[0][0] * BB1[0][1]) % im1 + (A1[0][1] * BB1[1][1]) % im1 + (A1[0][2] * BB1[2][1]) % im1) % im1;
		CC1[0][2] = ((A1[0][0] * BB1[0][2]) % im1 + (A1[0][1] * BB1[1][2]) % im1 + (A1[0][2] * BB1[2][2]) % im1) % im1;
		CC1[1][0] = ((A1[1][0] * BB1[0][0]) % im1 + (A1[1][1] * BB1[1][0]) % im1 + (A1[1][2] * BB1[2][0]) % im1) % im1;
		CC1[1][1] = ((A1[1][0] * BB1[0][1]) % im1 + (A1[1][1] * BB1[1][1]) % im1 + (A1[1][2] * BB1[2][1]) % im1) % im1;
		CC1[1][2] = ((A1[1][0] * BB1[0][2]) % im1 + (A1[1][1] * BB1[1][2]) % im1 + (A1[1][2] * BB1[2][2]) % im1) % im1;
		CC1[2][0] = ((A1[2][0] * BB1[0][0]) % im1 + (A1[2][1] * BB1[1][0]) % im1 + (A1[2][2] * BB1[2][0]) % im1) % im1;
		CC1[2][1] = ((A1[2][0] * BB1[0][1]) % im1 + (A1[2][1] * BB1[1][1]) % im1 + (A1[2][2] * BB1[2][1]) % im1) % im1;
		CC1[2][2] = ((A1[2][0] * BB1[0][2]) % im1 + (A1[2][1] * BB1[1][2]) % im1 + (A1[2][2] * BB1[2][2]) % im1) % im1;

		CC2[0][0] = ((A2[0][0] * BB2[0][0]) % im2 + (A2[0][1] * BB2[1][0]) % im2 + (A2[0][2] * BB2[2][0]) % im2) % im2;
		CC2[0][1] = ((A2[0][0] * BB2[0][1]) % im2 + (A2[0][1] * BB2[1][1]) % im2 + (A2[0][2] * BB2[2][1]) % im2) % im2;
		CC2[0][2] = ((A2[0][0] * BB2[0][2]) % im2 + (A2[0][1] * BB2[1][2]) % im2 + (A2[0][2] * BB2[2][2]) % im2) % im2;
		CC2[1][0] = ((A2[1][0] * BB2[0][0]) % im2 + (A2[1][1] * BB2[1][0]) % im2 + (A2[1][2] * BB2[2][0]) % im2) % im2;
		CC2[1][1] = ((A2[1][0] * BB2[0][1]) % im2 + (A2[1][1] * BB2[1][1]) % im2 + (A2[1][2] * BB2[2][1]) % im2) % im2;
		CC2[1][2] = ((A2[1][0] * BB2[0][2]) % im2 + (A2[1][1] * BB2[1][2]) % im2 + (A2[1][2] * BB2[2][2]) % im2) % im2;
		CC2[2][0] = ((A2[2][0] * BB2[0][0]) % im2 + (A2[2][1] * BB2[1][0]) % im2 + (A2[2][2] * BB2[2][0]) % im2) % im2;
		CC2[2][1] = ((A2[2][0] * BB2[0][1]) % im2 + (A2[2][1] * BB2[1][1]) % im2 + (A2[2][2] * BB2[2][1]) % im2) % im2;
		CC2[2][2] = ((A2[2][0] * BB2[0][2]) % im2 + (A2[2][1] * BB2[1][2]) % im2 + (A2[2][2] * BB2[2][2]) % im2) % im2;

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				BB1[i][j] = CC1[i][j];
				BB2[i][j] = CC2[i][j];
			}
		}

	}

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			Bn1[i][j] = BB1[i][j];
			Bn2[i][j] = BB2[i][j];
		}
	}

	return;

}

