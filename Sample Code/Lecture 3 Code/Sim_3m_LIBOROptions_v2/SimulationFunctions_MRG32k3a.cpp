//	Double precision simulation functions for uniform and normal only
#include "pch.h"
#include "SimulationFunctions_MRG32k3a.h"

double rand_u01(double dseed[])
{
	//	This code is an exact copy of the C code in L'Ecuyer (Operations Research 1999)
	const double norm = 2.328306549295728e-10;
	const double m1 = 4294967087.0;
	const double m2 = 4294944443.0;
	const double a12 = 1403580.0;
	const double a13n = 810728.0;
	const double a21 = 527612.0;
	const double a23n = 1370589.0;
	int k;
	double p1, p2;

	p1 = a12*dseed[1] - a13n*dseed[2];
	k = p1 / m1;
	p1 -= k*m1;
	if (p1 < 0.0) p1 += m1;
	dseed[2] = dseed[1]; dseed[1] = dseed[0]; dseed[0] = p1;

	p2 = a21*dseed[3] - a23n*dseed[5];
	k = p2 / m2;
	p2 -= k*m2;
	if (p2 < 0.0) p2 += m2;
	dseed[5] = dseed[4]; dseed[4] = dseed[3]; dseed[3] = p2;

	if (p1 <= p2) return ((p1 - p2 + m1)*norm);
	else return ((p1 - p2)*norm);

}

void roll_seed(double dseed[])
{
	const double m1 = 4294967087.0;
	const double m2 = 4294944443.0;
	const double a12 = 1403580.0;
	const double a13n = 810728.0;
	const double a21 = 527612.0;
	const double a23n = 1370589.0;
	int k;
	double p1, p2;

	p1 = a12*dseed[1] - a13n*dseed[2];
	k = p1 / m1;
	p1 -= k*m1;
	if (p1 < 0.0) p1 += m1;
	dseed[2] = dseed[1]; dseed[1] = dseed[0]; dseed[0] = p1;

	p2 = a21*dseed[3] - a23n*dseed[5];
	k = p2 / m2;
	p2 -= k*m2;
	if (p2 < 0.0) p2 += m2;
	dseed[5] = dseed[4]; dseed[4] = dseed[3]; dseed[3] = p2;

	return;

}

//	This method is slightly faster and accurate (always spot on, matches brute force rolling of seeds)
//	This method is very fast because it uses divide and conquer
void SkipAhead_MRG32k3a(int n, unsigned int **An1, unsigned int **An2)
{
	const unsigned int im1 = 4294967087;
	const unsigned int im2 = 4294944443;
	const unsigned int ia12 = 1403580;
	const unsigned int ia13n = 810728;
	const unsigned int ia21 = 527612;
	const unsigned int ia23n = 1370589;
	int i, j, k, ii;
	long long lp1, lp2;
	long long A1[3][3], A2[3][3], B1[3][3], B2[3][3], C1[3][3], C2[3][3];
	unsigned long long BB1[3][3], BB2[3][3], CC1[3][3], CC2[3][3];

	A1[0][0] = 0; A1[0][1] = ia12;
	A1[0][2] = 0;
	A1[0][2] -= ia13n;
	A1[1][0] = 1; A1[1][1] = 0; A1[1][2] = 0;
	A1[2][0] = 0; A1[2][1] = 1; A1[2][2] = 0;

	A2[0][0] = ia21; A2[0][1] = 0;
	A2[0][2] = 0;
	A2[0][2] -= ia23n;
	A2[1][0] = 1; A2[1][1] = 0; A2[1][2] = 0;
	A2[2][0] = 0; A2[2][1] = 1; A2[2][2] = 0;

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			B1[i][j] = A1[i][j];
			B2[i][j] = A2[i][j];
		}
	}

	for (ii = 2; ii <= 4; ii++) {
		//	pre-multiply by Ai, calculating with 64 bit signed integers
		C1[0][0] = A1[0][0] * B1[0][0] + A1[0][1] * B1[1][0] + A1[0][2] * B1[2][0];
		C1[0][1] = A1[0][0] * B1[0][1] + A1[0][1] * B1[1][1] + A1[0][2] * B1[2][1];
		C1[0][2] = A1[0][0] * B1[0][2] + A1[0][1] * B1[1][2] + A1[0][2] * B1[2][2];
		C1[1][0] = A1[1][0] * B1[0][0] + A1[1][1] * B1[1][0] + A1[1][2] * B1[2][0];
		C1[1][1] = A1[1][0] * B1[0][1] + A1[1][1] * B1[1][1] + A1[1][2] * B1[2][1];
		C1[1][2] = A1[1][0] * B1[0][2] + A1[1][1] * B1[1][2] + A1[1][2] * B1[2][2];
		C1[2][0] = A1[2][0] * B1[0][0] + A1[2][1] * B1[1][0] + A1[2][2] * B1[2][0];
		C1[2][1] = A1[2][0] * B1[0][1] + A1[2][1] * B1[1][1] + A1[2][2] * B1[2][1];
		C1[2][2] = A1[2][0] * B1[0][2] + A1[2][1] * B1[1][2] + A1[2][2] * B1[2][2];

		C2[0][0] = A2[0][0] * B2[0][0] + A2[0][1] * B2[1][0] + A2[0][2] * B2[2][0];
		C2[0][1] = A2[0][0] * B2[0][1] + A2[0][1] * B2[1][1] + A2[0][2] * B2[2][1];
		C2[0][2] = A2[0][0] * B2[0][2] + A2[0][1] * B2[1][2] + A2[0][2] * B2[2][2];
		C2[1][0] = A2[1][0] * B2[0][0] + A2[1][1] * B2[1][0] + A2[1][2] * B2[2][0];
		C2[1][1] = A2[1][0] * B2[0][1] + A2[1][1] * B2[1][1] + A2[1][2] * B2[2][1];
		C2[1][2] = A2[1][0] * B2[0][2] + A2[1][1] * B2[1][2] + A2[1][2] * B2[2][2];
		C2[2][0] = A2[2][0] * B2[0][0] + A2[2][1] * B2[1][0] + A2[2][2] * B2[2][0];
		C2[2][1] = A2[2][0] * B2[0][1] + A2[2][1] * B2[1][1] + A2[2][2] * B2[2][1];
		C2[2][2] = A2[2][0] * B2[0][2] + A2[2][1] * B2[1][2] + A2[2][2] * B2[2][2];

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				lp1 = C1[i][j];
				lp1 = lp1 % im1;
				if (lp1 < 0) lp1 += im1;
				B1[i][j] = lp1;
				lp2 = C2[i][j];
				lp2 = lp2 % im2;
				if (lp2 < 0) lp2 += im2;
				B2[i][j] = lp2;
			}
		}

	}

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			BB1[i][j] = B1[i][j];
			BB2[i][j] = B2[i][j];
		}
	}

	ii = 8;
	while (ii <= n) {
		//	here we are squaring the matrix at each round
		CC1[0][0] = ((BB1[0][0] * BB1[0][0]) % im1 + (BB1[0][1] * BB1[1][0]) % im1 + (BB1[0][2] * BB1[2][0]) % im1) % im1;
		CC1[0][1] = ((BB1[0][0] * BB1[0][1]) % im1 + (BB1[0][1] * BB1[1][1]) % im1 + (BB1[0][2] * BB1[2][1]) % im1) % im1;
		CC1[0][2] = ((BB1[0][0] * BB1[0][2]) % im1 + (BB1[0][1] * BB1[1][2]) % im1 + (BB1[0][2] * BB1[2][2]) % im1) % im1;
		CC1[1][0] = ((BB1[1][0] * BB1[0][0]) % im1 + (BB1[1][1] * BB1[1][0]) % im1 + (BB1[1][2] * BB1[2][0]) % im1) % im1;
		CC1[1][1] = ((BB1[1][0] * BB1[0][1]) % im1 + (BB1[1][1] * BB1[1][1]) % im1 + (BB1[1][2] * BB1[2][1]) % im1) % im1;
		CC1[1][2] = ((BB1[1][0] * BB1[0][2]) % im1 + (BB1[1][1] * BB1[1][2]) % im1 + (BB1[1][2] * BB1[2][2]) % im1) % im1;
		CC1[2][0] = ((BB1[2][0] * BB1[0][0]) % im1 + (BB1[2][1] * BB1[1][0]) % im1 + (BB1[2][2] * BB1[2][0]) % im1) % im1;
		CC1[2][1] = ((BB1[2][0] * BB1[0][1]) % im1 + (BB1[2][1] * BB1[1][1]) % im1 + (BB1[2][2] * BB1[2][1]) % im1) % im1;
		CC1[2][2] = ((BB1[2][0] * BB1[0][2]) % im1 + (BB1[2][1] * BB1[1][2]) % im1 + (BB1[2][2] * BB1[2][2]) % im1) % im1;

		CC2[0][0] = ((BB2[0][0] * BB2[0][0]) % im2 + (BB2[0][1] * BB2[1][0]) % im2 + (BB2[0][2] * BB2[2][0]) % im2) % im2;
		CC2[0][1] = ((BB2[0][0] * BB2[0][1]) % im2 + (BB2[0][1] * BB2[1][1]) % im2 + (BB2[0][2] * BB2[2][1]) % im2) % im2;
		CC2[0][2] = ((BB2[0][0] * BB2[0][2]) % im2 + (BB2[0][1] * BB2[1][2]) % im2 + (BB2[0][2] * BB2[2][2]) % im2) % im2;
		CC2[1][0] = ((BB2[1][0] * BB2[0][0]) % im2 + (BB2[1][1] * BB2[1][0]) % im2 + (BB2[1][2] * BB2[2][0]) % im2) % im2;
		CC2[1][1] = ((BB2[1][0] * BB2[0][1]) % im2 + (BB2[1][1] * BB2[1][1]) % im2 + (BB2[1][2] * BB2[2][1]) % im2) % im2;
		CC2[1][2] = ((BB2[1][0] * BB2[0][2]) % im2 + (BB2[1][1] * BB2[1][2]) % im2 + (BB2[1][2] * BB2[2][2]) % im2) % im2;
		CC2[2][0] = ((BB2[2][0] * BB2[0][0]) % im2 + (BB2[2][1] * BB2[1][0]) % im2 + (BB2[2][2] * BB2[2][0]) % im2) % im2;
		CC2[2][1] = ((BB2[2][0] * BB2[0][1]) % im2 + (BB2[2][1] * BB2[1][1]) % im2 + (BB2[2][2] * BB2[2][1]) % im2) % im2;
		CC2[2][2] = ((BB2[2][0] * BB2[0][2]) % im2 + (BB2[2][1] * BB2[1][2]) % im2 + (BB2[2][2] * BB2[2][2]) % im2) % im2;

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				BB1[i][j] = CC1[i][j];
				BB2[i][j] = CC2[i][j];
			}

		}

		ii = 2 * ii;
	}

	k = ii / 2;
	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			B1[i][j] = BB1[i][j];
			B2[i][j] = BB2[i][j];
		}
	}

	for (ii = (k + 1); ii <= n; ii++) {
		//	pre-multiply by Ai, calculating with 64 bit signed integers
		C1[0][0] = A1[0][0] * B1[0][0] + A1[0][1] * B1[1][0] + A1[0][2] * B1[2][0];
		C1[0][1] = A1[0][0] * B1[0][1] + A1[0][1] * B1[1][1] + A1[0][2] * B1[2][1];
		C1[0][2] = A1[0][0] * B1[0][2] + A1[0][1] * B1[1][2] + A1[0][2] * B1[2][2];
		C1[1][0] = A1[1][0] * B1[0][0] + A1[1][1] * B1[1][0] + A1[1][2] * B1[2][0];
		C1[1][1] = A1[1][0] * B1[0][1] + A1[1][1] * B1[1][1] + A1[1][2] * B1[2][1];
		C1[1][2] = A1[1][0] * B1[0][2] + A1[1][1] * B1[1][2] + A1[1][2] * B1[2][2];
		C1[2][0] = A1[2][0] * B1[0][0] + A1[2][1] * B1[1][0] + A1[2][2] * B1[2][0];
		C1[2][1] = A1[2][0] * B1[0][1] + A1[2][1] * B1[1][1] + A1[2][2] * B1[2][1];
		C1[2][2] = A1[2][0] * B1[0][2] + A1[2][1] * B1[1][2] + A1[2][2] * B1[2][2];

		C2[0][0] = A2[0][0] * B2[0][0] + A2[0][1] * B2[1][0] + A2[0][2] * B2[2][0];
		C2[0][1] = A2[0][0] * B2[0][1] + A2[0][1] * B2[1][1] + A2[0][2] * B2[2][1];
		C2[0][2] = A2[0][0] * B2[0][2] + A2[0][1] * B2[1][2] + A2[0][2] * B2[2][2];
		C2[1][0] = A2[1][0] * B2[0][0] + A2[1][1] * B2[1][0] + A2[1][2] * B2[2][0];
		C2[1][1] = A2[1][0] * B2[0][1] + A2[1][1] * B2[1][1] + A2[1][2] * B2[2][1];
		C2[1][2] = A2[1][0] * B2[0][2] + A2[1][1] * B2[1][2] + A2[1][2] * B2[2][2];
		C2[2][0] = A2[2][0] * B2[0][0] + A2[2][1] * B2[1][0] + A2[2][2] * B2[2][0];
		C2[2][1] = A2[2][0] * B2[0][1] + A2[2][1] * B2[1][1] + A2[2][2] * B2[2][1];
		C2[2][2] = A2[2][0] * B2[0][2] + A2[2][1] * B2[1][2] + A2[2][2] * B2[2][2];

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				lp1 = C1[i][j];
				lp1 = lp1 % im1;
				if (lp1 < 0) lp1 += im1;
				B1[i][j] = lp1;
				lp2 = C2[i][j];
				lp2 = lp2 % im2;
				if (lp2 < 0) lp2 += im2;
				B2[i][j] = lp2;
			}
		}
	}

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			An1[i][j] = B1[i][j];
			An2[i][j] = B2[i][j];
		}
	}

	return;

}

void SkipAhead2_MRG32k3a(int n, unsigned int **An1, unsigned int **An2, unsigned int **Bn1, unsigned int **Bn2)
{
	const unsigned int im1 = 4294967087;
	const unsigned int im2 = 4294944443;
	int i, j, k, ii;
//	long long kmod, lp1, lp2;
	unsigned long long A1[3][3], A2[3][3], BB1[3][3], BB2[3][3], CC1[3][3], CC2[3][3];

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			A1[i][j] = An1[i][j];
			A2[i][j] = An2[i][j];
			BB1[i][j] = An1[i][j];
			BB2[i][j] = An2[i][j];
		}
	}

	ii = 2;
	while (ii <= n) {
		//	here we are squaring the matrix at each round
		CC1[0][0] = ((BB1[0][0] * BB1[0][0]) % im1 + (BB1[0][1] * BB1[1][0]) % im1 + (BB1[0][2] * BB1[2][0]) % im1) % im1;
		CC1[0][1] = ((BB1[0][0] * BB1[0][1]) % im1 + (BB1[0][1] * BB1[1][1]) % im1 + (BB1[0][2] * BB1[2][1]) % im1) % im1;
		CC1[0][2] = ((BB1[0][0] * BB1[0][2]) % im1 + (BB1[0][1] * BB1[1][2]) % im1 + (BB1[0][2] * BB1[2][2]) % im1) % im1;
		CC1[1][0] = ((BB1[1][0] * BB1[0][0]) % im1 + (BB1[1][1] * BB1[1][0]) % im1 + (BB1[1][2] * BB1[2][0]) % im1) % im1;
		CC1[1][1] = ((BB1[1][0] * BB1[0][1]) % im1 + (BB1[1][1] * BB1[1][1]) % im1 + (BB1[1][2] * BB1[2][1]) % im1) % im1;
		CC1[1][2] = ((BB1[1][0] * BB1[0][2]) % im1 + (BB1[1][1] * BB1[1][2]) % im1 + (BB1[1][2] * BB1[2][2]) % im1) % im1;
		CC1[2][0] = ((BB1[2][0] * BB1[0][0]) % im1 + (BB1[2][1] * BB1[1][0]) % im1 + (BB1[2][2] * BB1[2][0]) % im1) % im1;
		CC1[2][1] = ((BB1[2][0] * BB1[0][1]) % im1 + (BB1[2][1] * BB1[1][1]) % im1 + (BB1[2][2] * BB1[2][1]) % im1) % im1;
		CC1[2][2] = ((BB1[2][0] * BB1[0][2]) % im1 + (BB1[2][1] * BB1[1][2]) % im1 + (BB1[2][2] * BB1[2][2]) % im1) % im1;

		CC2[0][0] = ((BB2[0][0] * BB2[0][0]) % im2 + (BB2[0][1] * BB2[1][0]) % im2 + (BB2[0][2] * BB2[2][0]) % im2) % im2;
		CC2[0][1] = ((BB2[0][0] * BB2[0][1]) % im2 + (BB2[0][1] * BB2[1][1]) % im2 + (BB2[0][2] * BB2[2][1]) % im2) % im2;
		CC2[0][2] = ((BB2[0][0] * BB2[0][2]) % im2 + (BB2[0][1] * BB2[1][2]) % im2 + (BB2[0][2] * BB2[2][2]) % im2) % im2;
		CC2[1][0] = ((BB2[1][0] * BB2[0][0]) % im2 + (BB2[1][1] * BB2[1][0]) % im2 + (BB2[1][2] * BB2[2][0]) % im2) % im2;
		CC2[1][1] = ((BB2[1][0] * BB2[0][1]) % im2 + (BB2[1][1] * BB2[1][1]) % im2 + (BB2[1][2] * BB2[2][1]) % im2) % im2;
		CC2[1][2] = ((BB2[1][0] * BB2[0][2]) % im2 + (BB2[1][1] * BB2[1][2]) % im2 + (BB2[1][2] * BB2[2][2]) % im2) % im2;
		CC2[2][0] = ((BB2[2][0] * BB2[0][0]) % im2 + (BB2[2][1] * BB2[1][0]) % im2 + (BB2[2][2] * BB2[2][0]) % im2) % im2;
		CC2[2][1] = ((BB2[2][0] * BB2[0][1]) % im2 + (BB2[2][1] * BB2[1][1]) % im2 + (BB2[2][2] * BB2[2][1]) % im2) % im2;
		CC2[2][2] = ((BB2[2][0] * BB2[0][2]) % im2 + (BB2[2][1] * BB2[1][2]) % im2 + (BB2[2][2] * BB2[2][2]) % im2) % im2;

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				BB1[i][j] = CC1[i][j];
				BB2[i][j] = CC2[i][j];
			}
		}

		ii = 2 * ii;
	}

	k = ii / 2;

	for (ii = (k + 1); ii <= n; ii++) {
		//	pre-multiply by Ai, calculating with 64 bit signed integers

		CC1[0][0] = ((A1[0][0] * BB1[0][0]) % im1 + (A1[0][1] * BB1[1][0]) % im1 + (A1[0][2] * BB1[2][0]) % im1) % im1;
		CC1[0][1] = ((A1[0][0] * BB1[0][1]) % im1 + (A1[0][1] * BB1[1][1]) % im1 + (A1[0][2] * BB1[2][1]) % im1) % im1;
		CC1[0][2] = ((A1[0][0] * BB1[0][2]) % im1 + (A1[0][1] * BB1[1][2]) % im1 + (A1[0][2] * BB1[2][2]) % im1) % im1;
		CC1[1][0] = ((A1[1][0] * BB1[0][0]) % im1 + (A1[1][1] * BB1[1][0]) % im1 + (A1[1][2] * BB1[2][0]) % im1) % im1;
		CC1[1][1] = ((A1[1][0] * BB1[0][1]) % im1 + (A1[1][1] * BB1[1][1]) % im1 + (A1[1][2] * BB1[2][1]) % im1) % im1;
		CC1[1][2] = ((A1[1][0] * BB1[0][2]) % im1 + (A1[1][1] * BB1[1][2]) % im1 + (A1[1][2] * BB1[2][2]) % im1) % im1;
		CC1[2][0] = ((A1[2][0] * BB1[0][0]) % im1 + (A1[2][1] * BB1[1][0]) % im1 + (A1[2][2] * BB1[2][0]) % im1) % im1;
		CC1[2][1] = ((A1[2][0] * BB1[0][1]) % im1 + (A1[2][1] * BB1[1][1]) % im1 + (A1[2][2] * BB1[2][1]) % im1) % im1;
		CC1[2][2] = ((A1[2][0] * BB1[0][2]) % im1 + (A1[2][1] * BB1[1][2]) % im1 + (A1[2][2] * BB1[2][2]) % im1) % im1;

		CC2[0][0] = ((A2[0][0] * BB2[0][0]) % im2 + (A2[0][1] * BB2[1][0]) % im2 + (A2[0][2] * BB2[2][0]) % im2) % im2;
		CC2[0][1] = ((A2[0][0] * BB2[0][1]) % im2 + (A2[0][1] * BB2[1][1]) % im2 + (A2[0][2] * BB2[2][1]) % im2) % im2;
		CC2[0][2] = ((A2[0][0] * BB2[0][2]) % im2 + (A2[0][1] * BB2[1][2]) % im2 + (A2[0][2] * BB2[2][2]) % im2) % im2;
		CC2[1][0] = ((A2[1][0] * BB2[0][0]) % im2 + (A2[1][1] * BB2[1][0]) % im2 + (A2[1][2] * BB2[2][0]) % im2) % im2;
		CC2[1][1] = ((A2[1][0] * BB2[0][1]) % im2 + (A2[1][1] * BB2[1][1]) % im2 + (A2[1][2] * BB2[2][1]) % im2) % im2;
		CC2[1][2] = ((A2[1][0] * BB2[0][2]) % im2 + (A2[1][1] * BB2[1][2]) % im2 + (A2[1][2] * BB2[2][2]) % im2) % im2;
		CC2[2][0] = ((A2[2][0] * BB2[0][0]) % im2 + (A2[2][1] * BB2[1][0]) % im2 + (A2[2][2] * BB2[2][0]) % im2) % im2;
		CC2[2][1] = ((A2[2][0] * BB2[0][1]) % im2 + (A2[2][1] * BB2[1][1]) % im2 + (A2[2][2] * BB2[2][1]) % im2) % im2;
		CC2[2][2] = ((A2[2][0] * BB2[0][2]) % im2 + (A2[2][1] * BB2[1][2]) % im2 + (A2[2][2] * BB2[2][2]) % im2) % im2;

		for (i = 0; i < 3; i++) {
			for (j = 0; j < 3; j++) {
				BB1[i][j] = CC1[i][j];
				BB2[i][j] = CC2[i][j];
			}
		}

	}

	for (i = 0; i < 3; i++) {
		for (j = 0; j < 3; j++) {
			Bn1[i][j] = BB1[i][j];
			Bn2[i][j] = BB2[i][j];
		}
	}

	return;

}


double sninvdev(double dseed[])
{
	const double norm = 2.328306549295728e-10;
	const double m1 = 4294967087.0;
	const double m2 = 4294944443.0;
	const double a12 = 1403580.0;
	const double a13n = 810728.0;
	const double a21 = 527612.0;
	const double a23n = 1370589.0;
	int k;
	double q, r, ans, p, p1, p2;

	p1 = a12*dseed[1] - a13n*dseed[2];
	k = p1 / m1;
	p1 -= k*m1;
	if (p1 < 0.0) p1 += m1;
	dseed[2] = dseed[1]; dseed[1] = dseed[0]; dseed[0] = p1;

	p2 = a21*dseed[3] - a23n*dseed[5];
	k = p2 / m2;
	p2 -= k*m2;
	if (p2 < 0.0) p2 += m2;
	dseed[5] = dseed[4]; dseed[4] = dseed[3]; dseed[3] = p2;

	if (p1 <= p2) p = ((p1 - p2 + m1)*norm);
	else p = ((p1 - p2)*norm);
	
	if (p <= 0.0) {
		ans = -100.0;
	}
	else {
		if (p >= 1.0) ans = 100.00;

		else {
			if (p < 0.02425) {
				q = sqrt(-2.0*log(p));
				ans = (((((-0.007784894002430293*q - 0.3223964580411365)*q - 2.400758277161838)*q - 2.549732539343734)*q + 4.374664141464968)*q + 2.938163982698783) /
					((((0.007784695709041462*q + 0.3224671290700398)*q + 2.445134137142996)*q + 3.754408661907416)*q + 1.0);
			}
			else {
				if (p < 0.97575) {
					q = p - 0.5;
					r = q*q;
					ans = (((((-39.69683028665376*r + 220.9460984245205)*r - 275.9285104469687)*r + 138.3577518672690)*r - 30.66479806614716)*r + 2.506628277459239)*q /
						(((((-54.47609879822406*r + 161.5858368580409)*r - 155.6989798598866)*r + 66.80131188771972)*r - 13.28068155288572)*r + 1.0);
				}
				else {
					if (p < 0.99) {
						q = sqrt(-2.0*log(1.0 - p));
						ans = -(((((-0.007784894002430293*q - 0.3223964580411365)*q - 2.400758277161838)*q - 2.549732539343734)*q + 4.374664141464968)*q + 2.938163982698783) /
							((((0.007784695709041462*q + 0.3224671290700398)*q + 2.445134137142996)*q + 3.754408661907416)*q + 1.0);
					}
					else {
						q = sqrt(-2.0*log(1 - p));
						ans = -(((((-0.007784894002430293*q - 0.3223964580411365)*q - 2.400758277161838)*q - 2.549732539343734)*q + 4.374664141464968)*q + 2.938163982698783) /
							((((0.007784695709041462*q + 0.3224671290700398)*q + 2.445134137142996)*q + 3.754408661907416)*q + 1.0);
					}
				}
			}
		}
	}

	return ans;

}